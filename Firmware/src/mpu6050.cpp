
#include "mpu6050.h"

#include <string.h>
#include <stdio.h>

static float Acc_Sensitivity = 16384.0;
static float GYRO_Sensitivity = 131.0;

#ifdef __cplusplus
extern "C"
{
#endif
#ifdef __cplusplus
}
#endif

#define USE_DMP_MEMORY 1
#define MPU6050_DMP_CODE_SIZE 1929  // dmpMemory[]
#define MPU6050_DMP_CONFIG_SIZE 192 // dmpConfig[]
#define MPU6050_DMP_UPDATES_SIZE 47 // dmpUpdates[]
#define MPU6050_DMP_PACKEDSIZE 42

/* ================================================================================================ *
 | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |
 |                                                                                                  |
 | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
 |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
 |                                                                                                  |
 | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
 |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
 * ================================================================================================ */

// this block of memory gets written to the MPU on start-up, and it seems
// to be volatile memory, so it has to be done each time (it only takes ~1
// second though)

// I Only Changed this by applying all the configuration data and capturing it before startup:
// *** this is a capture of the DMP Firmware after all the messy changes were made so we can just load it
#ifdef USE_DMP_MEMORY
// clang-format off
static const unsigned char dmpMemory[MPU6050_DMP_CODE_SIZE] = {
	/* bank # 0 */
	0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCB, 0x47, 0xA2, 0x20, 0x00, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
	0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
	0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
	0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
	0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
	/* bank # 1 */
	0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
	0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
	0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x23, 0xA1, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
	0x80, 0x00, 0xFF, 0xFF, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
	0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
	/* bank # 2 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x01, 0x00, 0x05, 0x8B, 0xC1, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* bank # 3 */
	0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
	0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
	0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
	0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
	0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
	0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
	0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
	0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0x4C, 0xCD, 0x6C, 0xA9, 0x0C,
	0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
	0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
	0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
	0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
	0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
	0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
	0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
	0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
	/* bank # 4 */
	0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
	0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
	0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
	0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
	0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
	0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
	0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
	0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
	0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
	0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
	0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
	0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
	/* bank # 5 */
	0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
	0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
	0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
	0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
	0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
	0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
	0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
	0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
	0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
	0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
	0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
	0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
	0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
	0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
	0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
	0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
	/* bank # 6 */
	0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
	0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
	0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
	0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
	0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
	0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
	0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
	0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
	0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
	0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
	0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
	0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
	0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
	0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
	0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
	0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
	/* bank # 7 */
	0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
	0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
	0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
	0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
	0xDD, 0xF1, 0x20, 0x28, 0x30, 0x38, 0x9A, 0xF1, 0x28, 0x30, 0x38, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
	0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
	0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0x28, 0x30, 0x38,
	0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0x30, 0xDC,
	0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xFE, 0xD8, 0xFF,
};
// clang-format on
#ifndef MPU6050_DMP_FIFO_RATE_DIVISOR
#define MPU6050_DMP_FIFO_RATE_DIVISOR 0x01
#endif
#endif

mpu6050::mpu6050()
{
}
mpu6050::~mpu6050()
{
    if (i2c)
        delete i2c;
}
MPU6050_ERROR mpu6050::initMPU6050(int sda_pin, int scl_pin, int i2c_freq_hz)
{
    i2c = new gen_i2c(sda_pin, scl_pin, i2c_freq_hz, MPU6050_ADDRESS, I2C_NUM_0);
    if (!i2c->i2c_probe())
        return CONNECTION_FAILED;

    i2c->write_byte(MPU6050_PWR, 0x0);

    DEBUG_PRINTLN("Hardware Revision %d", getRevision());
    setScaleAccelRange(ACCEL_SCALE_4G);
    setScaleGyroRange(GYRO_SCALE_500);
    setClockSource(MPU6050_CLOCK_PLL_ZGYRO);
    // calibration();

    setSampleRate(1);
    setDLPFMode(DLPF_94_98);

#ifdef USE_DMP_MEMORY
    DEBUG_PRINTLN("Setting slave 0 address to 0x7F...");
    setSlaveAddress(0, 0x7F);
    DEBUG_PRINTLN("Disabling I2C Master mode...");
    setI2CMasterModeEnabled(false);
    DEBUG_PRINTLN("Setting slave 0 address to 0x68 (self)...");
    setSlaveAddress(0, 0x68);
    DEBUG_PRINTLN("Resetting I2C Master control...");
    resetI2CMaster();

    setDMPEnabled(false);
    setFIFOEnabled(false);

    DEBUG_PRINTLN("Writing DMP code to MPU memory banks..");
    if (writeMemoryBlock(dmpMemory, MPU6050_DMP_CODE_SIZE, 0, 0, true, false) != SUCCESS)
    {
        DEBUG_PRINTLN("DMP WriteMemory FAILED");
    }
    DEBUG_PRINTLN("DMP WriteMemory SUCCESS");
    uint8_t dmpUpdate[] = {0x00, MPU6050_DMP_FIFO_RATE_DIVISOR};
    // Lets write the dmpUpdate data to the Firmware image, we have 2 bytes to write in bank 0x02 with the Offset 0x16
    if (writeMemoryBlock(dmpUpdate, 0x02, 0x02, 0x16, true, true) != SUCCESS)
    {
        DEBUG_PRINTLN("Firmware image WriteMemory FAILED");
    }
    DEBUG_PRINTLN("Firmware image WriteMemory SUCCESS");

    // DEBUG_PRINTLN("GyroOffset: %6d, %6d, %6d", gyro_offset.Vec_0, gyro_offset.Vec_1, gyro_offset.Vec_2);
    //  setGyroOffset(gyro_offset.Vec_0, gyro_offset.Vec_1, gyro_offset.Vec_2);

    setDMPConfig1(0x03);
    setDMPConfig2(0x00);
    setOTPBankValid(false);

    resetDMP();
    setDMPEnabled(true);
    resetFIFO();
    setFIFOEnabled(true);
#endif
    return SUCCESS;
}

uint8_t mpu6050::getRevision()
{
    setMemoryStartAddress(0x10, true, true, 0x06);
    uint8_t revision;
    i2c->read_byte(MPU6050_MEM_R_W, &revision);
    setMemoryStartAddress(0, false, false, 0);
    return revision;
}
void mpu6050::setMemoryStartAddress(uint8_t bank, bool prefetchEnabled, bool userBank, uint8_t startAddress)
{
    bank &= 0x1F;
    if (userBank)
        bank |= 0x20;
    if (prefetchEnabled)
        bank |= 0x40;
    i2c->write_byte(MPU6050_BANK_SEL, bank);
    i2c->write_byte(MPU6050_MEM_START_ADDR, startAddress);
}

MPU6050_ERROR mpu6050::setScaleAccelRange(ACCEL_SCALE range)
{
    switch (range)
    {
    case ACCEL_SCALE_2G:
        Acc_Sensitivity = 16384.0;
        break;
    case ACCEL_SCALE_4G:
        Acc_Sensitivity = 8192.0;
        break;
    case ACCEL_SCALE_8G:
        Acc_Sensitivity = 4096.0;
        break;
    case ACCEL_SCALE_16G:
        Acc_Sensitivity = 2048.0;
        break;
    default:
        return SETTING_FAILED;
    }
    uint8_t data;
    i2c->read_byte(MPU6050_ACCEL_SCALE_CONFIG, &data);
    data = AND(data, range << MPU6050_SCALE_BIT, 0b11 << MPU6050_SCALE_BIT);
    i2c->write_byte(MPU6050_ACCEL_SCALE_CONFIG, data);
    i2c->read_byte(MPU6050_ACCEL_SCALE_CONFIG, &data);
    return SUCCESS;
}
MPU6050_ERROR mpu6050::setScaleGyroRange(GYRO_SCALE range)
{
    switch (range)
    {
    case GYRO_SCALE_250:
        GYRO_Sensitivity = 131.0;
        break;
    case GYRO_SCALE_500:
        GYRO_Sensitivity = 65.5;
        break;
    case GYRO_SCALE_1000:
        GYRO_Sensitivity = 32.8;
        break;
    case GYRO_SCALE_2000:
        GYRO_Sensitivity = 16.4;
        break;
    default:
        return SETTING_FAILED;
    }
    uint8_t data;
    i2c->read_byte(MPU6050_GYRO_SCALE_CONFIG, &data);
    data = AND(data, range << MPU6050_SCALE_BIT, 0b11 << MPU6050_SCALE_BIT);
    i2c->write_byte(MPU6050_GYRO_SCALE_CONFIG, data);
    i2c->read_byte(MPU6050_GYRO_SCALE_CONFIG, &data);
    return SUCCESS;
}
MPU6050_ERROR mpu6050::setClockSource(CLOCK_SOURCE source)
{
    uint8_t data;
    i2c->read_byte(MPU6050_PWR_MGMT_1, &data);
    data = AND(data, source, CREATE_MASK(3));
    i2c->write_byte(MPU6050_PWR_MGMT_1, data);
    return SUCCESS;
}
MPU6050_ERROR mpu6050::setSampleRate(uint8_t rate)
{
    i2c->write_byte(MPU6050_SMPLRT_DIV, rate);
    return SUCCESS;
}
MPU6050_ERROR mpu6050::setDLPFMode(DLPF_MODE mode)
{
    uint8_t data;
    i2c->read_byte(MPU6050_CONFIG, &data);
    data = AND(data, mode, CREATE_MASK(3));
    i2c->write_byte(MPU6050_CONFIG, data);
    return SUCCESS;
}

void mpu6050::setSlaveAddress(uint8_t num, uint8_t address)
{
    if (num <= 3)
        i2c->write_byte(MPU6050_I2C_SLV0_ADDR + num * 3, address);
}
void mpu6050::setI2CMasterModeEnabled(bool enabled)
{
    uint8_t data;
    i2c->read_byte(MPU6050_USER_CTRL, &data);
    data = AND(data, enabled ? 0XFF : 0X00, (1 << MPU6050_USERCTRL_I2C_MST_EN_BIT));
    i2c->write_byte(MPU6050_USER_CTRL, data);
}
void mpu6050::resetI2CMaster()
{
    uint8_t data;
    i2c->read_byte(MPU6050_USER_CTRL, &data);
    data |= (1 << MPU6050_USERCTRL_I2C_MST_RESET_BIT);
    i2c->write_byte(MPU6050_USER_CTRL, data);
}

MPU6050_ERROR mpu6050::writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address, bool verify, bool useProgMem)
{
    setMemoryStartAddress(bank, false, false, address);
    uint8_t chunkSize;
    uint8_t *verifyBuffer = 0;
    uint8_t *progBuffer = 0;
    if (verify)
        verifyBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);
    if (useProgMem)
        progBuffer = (uint8_t *)malloc(MPU6050_DMP_MEMORY_CHUNK_SIZE);

    for (uint16_t i = 0; i < dataSize;)
    {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize)
            chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address)
            chunkSize = 256 - address;
        // write the chunk of data as specified
        if (useProgMem)
        {
            for (uint8_t j = 0; j < chunkSize; j++)
                progBuffer[j] = *(data + i + j);
        }
        else
            progBuffer = (uint8_t *)data + i;
        i2c->write_bytes(MPU6050_MEM_R_W, chunkSize, progBuffer);
        if (verify)
        {
            // verify data
            setMemoryStartAddress(bank, false, false, address);
            i2c->read_bytes(MPU6050_MEM_R_W, chunkSize, verifyBuffer);
            // DEBUG_PRINT("Bank %d:", bank);
            // for (uint8_t j = 0; j < chunkSize; j++)
            //     DEBUG_PRINT("[%02X|%02X],", progBuffer[j], verifyBuffer[j]);
            // DEBUG_PRINT("\r\n");
            if (memcmp(progBuffer, verifyBuffer, chunkSize) != 0)
            {
                free(verifyBuffer);
                if (useProgMem)
                    free(progBuffer);
                return WRITEMEMORY_FAILED;
            }
        }

        // increase byte index by [chunkSize]
        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize)
        {
            if (address == 0)
                bank++;
            setMemoryStartAddress(bank, false, false, address);
        }
    }

    if (verify)
        free(verifyBuffer);
    if (useProgMem)
        free(progBuffer);
    return SUCCESS;
}
void mpu6050::setDMPConfig1(uint8_t config)
{
    i2c->write_byte(MPU6050_DMP_CFG_1, config);
}
void mpu6050::setDMPConfig2(uint8_t config)
{
    i2c->write_byte(MPU6050_DMP_CFG_2, config);
}
void mpu6050::setOTPBankValid(bool enabled)
{
    uint8_t data;
    i2c->read_byte(MPU6050_XG_OFFS_TC, &data);
    data = AND(data, enabled ? 0XFF : 0X00, (1 << MPU6050_TC_OTP_BNK_VLD_BIT));
    i2c->write_byte(MPU6050_XG_OFFS_TC, data);
}
void mpu6050::setDMPEnabled(bool enabled)
{
    uint8_t data;
    i2c->read_byte(MPU6050_USER_CTRL, &data);
    data = AND(data, enabled ? 0XFF : 0X00, (1 << MPU6050_USERCTRL_DMP_EN_BIT));
    i2c->write_byte(MPU6050_USER_CTRL, data);
}
void mpu6050::resetDMP()
{
    uint8_t data;
    i2c->read_byte(MPU6050_USER_CTRL, &data);
    data |= (1 << MPU6050_USERCTRL_DMP_RESET_BIT);
    i2c->write_byte(MPU6050_USER_CTRL, data);
}
void mpu6050::setFIFOEnabled(bool enabled)
{
    uint8_t data;
    i2c->read_byte(MPU6050_USER_CTRL, &data);
    data = AND(data, enabled ? 0XFF : 0X00, (1 << MPU6050_USERCTRL_FIFO_EN_BIT));
    i2c->write_byte(MPU6050_USER_CTRL, data);
}
void mpu6050::resetFIFO()
{
    uint8_t data;
    i2c->read_byte(MPU6050_USER_CTRL, &data);
    data |= (1 << MPU6050_USERCTRL_FIFO_RESET_BIT);
    i2c->write_byte(MPU6050_USER_CTRL, data);
}
int16_t mpu6050::getFIFOCount()
{
    uint8_t buffer[2];
    i2c->read_bytes(MPU6050_FIFO_COUNT, 2, buffer);
    return (((uint16_t)buffer[0]) << 8) | buffer[1];
}
uint8_t mpu6050::dmpReadFIFOPacket(FIFOPacket *packet)
{
    uint8_t buffer[MPU6050_DMP_PACKEDSIZE];
    i2c->read_bytes(MPU6050_FIFO_R_W, MPU6050_DMP_PACKEDSIZE, buffer);

    Vec4i rawquate;
    Vec3i rawacc, rawgyro;

    rawquate.Vec_0 = (buffer[0] << 8) | buffer[1];
    rawquate.Vec_1 = (buffer[4] << 8) | buffer[5];
    rawquate.Vec_2 = (buffer[8] << 8) | buffer[9];
    rawquate.Vec_3 = (buffer[12] << 8) | buffer[13];
    rawacc.Vec_0 = (buffer[28] << 8) | buffer[29];
    rawacc.Vec_1 = (buffer[32] << 8) | buffer[33];
    rawacc.Vec_2 = (buffer[36] << 8) | buffer[37];
    rawgyro.Vec_0 = (buffer[16] << 8) | buffer[17];
    rawgyro.Vec_1 = (buffer[20] << 8) | buffer[21];
    rawgyro.Vec_2 = (buffer[24] << 8) | buffer[25];

    Vec4f quate;
    Vec3f acc, gyro;
    convertToQuate(&rawquate, &quate);
    convertToAcc(&rawacc, &acc);
    convertToGyro(&rawgyro, &gyro);
    packet->Quate_W = quate.Vec_0;
    packet->Quate_X = quate.Vec_1;
    packet->Quate_Y = quate.Vec_2;
    packet->Quate_Z = quate.Vec_3;
    packet->Accel_X = acc.Vec_0;
    packet->Accel_Y = acc.Vec_1;
    packet->Accel_Z = acc.Vec_2;
    packet->Gyro_X = gyro.Vec_0;
    packet->Gyro_Y = gyro.Vec_1;
    packet->Gyro_Z = gyro.Vec_2;

    return 0;
}

void mpu6050::setAccOffset(int8_t xOffset, int8_t yOffset, int8_t zOffset)
{
}
void mpu6050::setGyroOffset(int8_t xOffset, int8_t yOffset, int8_t zOffset)
{
    uint8_t data;

    i2c->read_byte(MPU6050_XG_OFFS_TC, &data);
    /*for (int i = 7; i >= 0; i--)
        printf("%d", (int)((data >> i) & 1));
    printf("\r\n");*/
    data = AND(data, 0XFF, 0b01111110);
    /*for (int i = 7; i >= 0; i--)
        printf("%d", (int)((data >> i) & 1));
    printf("\r\n");*/
    i2c->write_byte(MPU6050_XG_OFFS_TC, data);

    i2c->read_byte(MPU6050_YG_OFFS_TC, &data);
    data = AND(data, 0XFF, 0b01111110);
    i2c->write_byte(MPU6050_YG_OFFS_TC, data);

    i2c->read_byte(MPU6050_ZG_OFFS_TC, &data);
    data = AND(data, 0XFF, 0b01111110);
    i2c->write_byte(MPU6050_ZG_OFFS_TC, data);
}
void mpu6050::calibrateGyroOffset(uint64_t calibrateNum, Vec3i *offset)
{
    Vec3f tdata;
    for (uint64_t i = 0; i < calibrateNum; i++)
    {
        Vec3i data;
        getRawGyro(&data);
        tdata.Vec_0 += data.Vec_0;
        tdata.Vec_1 += data.Vec_1;
        tdata.Vec_2 += data.Vec_2;
    }
    offset->Vec_0 = (int)(tdata.Vec_0 / calibrateNum);
    offset->Vec_1 = (int)(tdata.Vec_1 / calibrateNum);
    offset->Vec_2 = (int)(tdata.Vec_2 / calibrateNum);
}

uint8_t mpu6050::getDeviceID()
{
    uint8_t buffer;
    i2c->read_byte(MPU6050_WHO_AM_I, &buffer);
    return (buffer >> 1) & CREATE_MASK(6);
}
float mpu6050::getTemp()
{
    uint8_t buffer[2];
    i2c->read_bytes(MPU6050_TEMP, 2, buffer);
    return ((int16_t)(buffer[0] << 8 | buffer[1])) / 340.0 + 36.53;
}

void mpu6050::getRawAcc(Vec3i *data)
{
    uint8_t buffer[6];
    i2c->read_bytes(MPU6050_Raw_ACC, 6, buffer);
    data->Vec_0 = (int16_t)(buffer[0] << 8 | buffer[1]);
    data->Vec_1 = (int16_t)(buffer[2] << 8 | buffer[3]);
    data->Vec_2 = (int16_t)(buffer[4] << 8 | buffer[5]);
}
void mpu6050::getRawGyro(Vec3i *data)
{
    uint8_t buffer[6];
    i2c->read_bytes(MPU6050_Raw_GYRO, 6, buffer);
    data->Vec_0 = (int16_t)(buffer[0] << 8 | buffer[1]);
    data->Vec_1 = (int16_t)(buffer[2] << 8 | buffer[3]);
    data->Vec_2 = (int16_t)(buffer[4] << 8 | buffer[5]);
}

void mpu6050::convertToQuate(const Vec4i *sourceData, Vec4f *targetData)
{
    targetData->Vec_0 = sourceData->Vec_0 / Acc_Sensitivity;
    targetData->Vec_1 = sourceData->Vec_1 / Acc_Sensitivity;
    targetData->Vec_2 = sourceData->Vec_2 / Acc_Sensitivity;
    targetData->Vec_3 = sourceData->Vec_3 / Acc_Sensitivity;
}
void mpu6050::convertToAcc(const Vec3i *sourceData, Vec3f *targetData)
{
    targetData->Vec_0 = sourceData->Vec_0 / Acc_Sensitivity;
    targetData->Vec_1 = sourceData->Vec_1 / Acc_Sensitivity;
    targetData->Vec_2 = sourceData->Vec_2 / Acc_Sensitivity;
}
void mpu6050::convertToGyro(const Vec3i *sourceData, Vec3f *targetData)
{
    targetData->Vec_0 = sourceData->Vec_0 / GYRO_Sensitivity;
    targetData->Vec_1 = sourceData->Vec_1 / GYRO_Sensitivity;
    targetData->Vec_2 = sourceData->Vec_2 / GYRO_Sensitivity;
}
void mpu6050::calibration()
{
    calibrateAccel(6);
    calibrateGyro(6);
    DEBUG_PRINTLN("do 600 Readings");

    calibrateAccel(1);
    calibrateGyro(1);
    DEBUG_PRINTLN("700 Total Readings");

    calibrateAccel(1);
    calibrateGyro(1);
    DEBUG_PRINTLN("800 Total Readings");

    calibrateAccel(1);
    calibrateGyro(1);
    DEBUG_PRINTLN("900 Total Readings");

    calibrateAccel(1);
    calibrateGyro(1);
    DEBUG_PRINTLN("1000 Total Readings");

    DEBUG_PRINTLN("Calibration Done:");
}

void mpu6050::calibrateAccel(uint8_t Loops)
{
    float kP = 0.3;
    float kI = 20;
    float x = (100 - INTERPOLATION(Loops, 1, 5, 20, 0)) * 0.01;
    kP *= x;
    kI *= x;
    calibratePID(MPU6050_Raw_ACC, kP, kI, Loops);
    uint8_t shift = (getDeviceID() < 0x38) ? 2 : 3;
    uint8_t buffer[9];
    int16_t result[3];
    i2c->read_bytes(MPU6050_XA_OFFS_H, 3 * shift, buffer);
    for (int i = 0; i < 3; i++)
        result[i] = (buffer[0 + (i * shift)] << 8) | buffer[1 + (i * shift)];
    DEBUG_PRINTLN("CalibrateAccel Offset Result: %6d, %6d, %6d", result[0], result[1], result[2]);
}
void mpu6050::calibrateGyro(uint8_t Loops)
{
    double kP = 0.3;
    double kI = 90;
    float x = (100 - INTERPOLATION(Loops, 1, 5, 20, 0)) * 0.01;
    kP *= x;
    kI *= x;
    calibratePID(MPU6050_Raw_GYRO, kP, kI, Loops);
    uint8_t buffer[6];
    int16_t result[3];
    i2c->read_bytes(MPU6050_XG_OFFS_USRH, 6, buffer);
    for (int i = 0; i < 3; i++)
        result[i] = (buffer[0 + (i * 2)] << 8) | buffer[1 + (i * 2)];
    DEBUG_PRINTLN("CalibrateGyro Offset Result: %6d, %6d, %6d", result[0], result[1], result[2]);
}
void mpu6050::calibratePID(uint8_t ReadAddress, float kP, float kI, uint8_t Loops)
{
    uint8_t SaveAddress = (ReadAddress == MPU6050_Raw_ACC) ? ((getDeviceID() < 0x38) ? MPU6050_XA_OFFS_H : 0x77) : MPU6050_XG_OFFS_USRH;
    uint8_t buffer[2];
    int16_t Data;
    float Reading;
    int16_t BitZero[3];
    uint8_t shift = (SaveAddress == 0x77) ? 3 : 2;
    float Error, PTerm, ITerm[3];
    int16_t eSample;
    uint32_t eSum;

    for (int i = 0; i < 3; i++)
    {
        i2c->read_bytes(SaveAddress + (i * shift), 2, buffer);
        Data = (buffer[0] << 8) | buffer[1];
        Reading = Data;
        if (SaveAddress != MPU6050_XG_OFFS_USRH)
        {
            BitZero[i] = Data & 1; // Capture Bit Zero to properly handle Accelerometer calibration
            ITerm[i] = ((float)Reading) * 8;
        }
        else
            ITerm[i] = Reading * 4;
    }
    for (int L = 0; L < Loops; L++)
    {
        eSample = 0;
        for (int c = 0; c < 100; c++)
        { // 100 PI Calculations
            eSum = 0;
            for (int i = 0; i < 3; i++)
            {
                i2c->read_bytes(ReadAddress + (i * 2), 2, buffer);
                Data = (buffer[0] << 8) | buffer[1];
                Reading = Data;
                if ((ReadAddress == MPU6050_Raw_ACC) && (i == 2))
                    Reading -= Acc_Sensitivity; // remove Gravity
                Error = -Reading;
                eSum += ABS(Reading);
                PTerm = kP * Error;
                ITerm[i] += (Error * 0.001) * kI; // Integral term 1000 Calculations a second = 0.001
                if (SaveAddress != MPU6050_XG_OFFS_USRH)
                {
                    Data = ROUND((PTerm + ITerm[i]) / 8);  // Compute PID Output
                    Data = ((Data) & 0xFFFE) | BitZero[i]; // Insert Bit0 Saved at beginning
                }
                else
                    Data = ROUND((PTerm + ITerm[i]) / 4); // Compute PID Output

                buffer[0] = (Data >> 8) & 0xFF;
                buffer[1] = Data & 0xFF;
                i2c->write_bytes(SaveAddress + (i * shift), 2, buffer);
            }
            if ((c == 99) && eSum > 1000)
            { // Error is still to great to continue
                c = 0;
                DEBUG_PRINTLN("Error: %ld, Retry...", eSum);
            }
            if ((eSum * ((ReadAddress == 0x3B) ? .05 : 1)) < 5)
                eSample++; // Successfully found offsets prepare to  advance
            if ((eSum < 100) && (c > 10) && (eSample >= 10))
                break; // Advance to next Loop
            // vTaskDelay(pdMS_TO_TICKS(1));
        }
        kP *= .75;
        kI *= .75;
        for (int i = 0; i < 3; i++)
        {
            if (SaveAddress != MPU6050_XG_OFFS_USRH)
            {
                Data = ROUND((ITerm[i]) / 8);          // Compute PID Output
                Data = ((Data) & 0xFFFE) | BitZero[i]; // Insert Bit0 Saved at beginning
            }
            else
                Data = ROUND((ITerm[i]) / 4);
            buffer[0] = (Data >> 8) & 0xFF;
            buffer[1] = Data & 0xFF;
            i2c->write_bytes(SaveAddress + (i * shift), 2, buffer);
        }
        DEBUG_PRINTLN("Writing Data...");
    }
    resetFIFO();
    resetDMP();
}